<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Map Adaptors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Map Adaptors</div>  </div>
<div class="ingroups"><a class="el" href="a00595.html">Maps</a></div></div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This group contains map adaptors that are used to create "implicit" maps from other maps.</p>
<p>Most of them are <a class="el" href="a00312.html">read-only maps</a>. They can make arithmetic and logical operations between one or two maps (negation, shifting, addition, multiplication, logical 'and', 'or', 'not' etc.) or e.g. convert a map to another one of different Value type.</p>
<p>The typical usage of this classes is passing implicit maps to algorithms. If a function type algorithm is called then the function type map adaptors can be used comfortable. For example let's see the usage of map adaptors with the <code><a class="el" href="a00625.html#gacdf8d8f513b3e79f89b19c20f7755564" title="Generates an EPS file from a graph.">graphToEps()</a></code> function. </p>
<div class="fragment"><div class="line">Color nodeColor(<span class="keywordtype">int</span> deg) {</div>
<div class="line">  <span class="keywordflow">if</span> (deg &gt;= 2) {</div>
<div class="line">    <span class="keywordflow">return</span> Color(0.5, 0.0, 0.5);</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deg == 1) {</div>
<div class="line">    <span class="keywordflow">return</span> Color(1.0, 0.5, 1.0);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">return</span> Color(0.0, 0.0, 0.0);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">Digraph::NodeMap&lt;int&gt; degree_map(graph);</div>
<div class="line"></div>
<div class="line"><a class="code" href="a00625.html#gacdf8d8f513b3e79f89b19c20f7755564" title="Generates an EPS file from a graph.">graphToEps</a>(graph, <span class="stringliteral">&quot;graph.eps&quot;</span>)</div>
<div class="line">  .coords(coords).scaleToA4().undirected()</div>
<div class="line">  .nodeColors(composeMap(functorToMap(nodeColor), degree_map))</div>
<div class="line">  .run();</div>
</div><!-- fragment --><p> The <code><a class="el" href="a00597.html#gab0aac0bb0604df94df88ad5fef5f391c" title="Returns a FunctorToMap class.">functorToMap()</a></code> function makes an <code>int</code> to <code><a class="el" href="a00086.html">Color</a></code> map from the <code>nodeColor()</code> function. The <code><a class="el" href="a00597.html#gac36b354e8e808fba48e18cf15db5100f" title="Returns a ComposeMap class.">composeMap()</a></code> compose the <code>degree_map</code> and the previously created map. The composed map is a proper function to get the color of each node.</p>
<p>The usage with class type algorithms is little bit harder. In this case the function type map adaptors can not be used, because the function map adaptors give back temporary objects. </p>
<div class="fragment"><div class="line">Digraph graph;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> Digraph::ArcMap&lt;double&gt; DoubleArcMap;</div>
<div class="line">DoubleArcMap length(graph);</div>
<div class="line">DoubleArcMap speed(graph);</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> DivMap&lt;DoubleArcMap, DoubleArcMap&gt; TimeMap;</div>
<div class="line">TimeMap time(length, speed);</div>
<div class="line"></div>
<div class="line">Dijkstra&lt;Digraph, TimeMap&gt; <a class="code" href="a00604.html#gaa781be76e5adb6a9df7592457a5c3857" title="Function-type interface for Dijkstra algorithm.">dijkstra</a>(graph, time);</div>
<div class="line"><a class="code" href="a00604.html#gaa781be76e5adb6a9df7592457a5c3857" title="Function-type interface for Dijkstra algorithm.">dijkstra</a>.run(source, target);</div>
</div><!-- fragment --><p> We have a length map and a maximum speed map on the arcs of a digraph. The minimum time to pass the arc can be calculated as the division of the two maps which can be done implicitly with the <code><a class="el" href="a00133.html" title="Quotient of two maps.">DivMap</a></code> template class. We use the implicit minimum time map as the length map of the <code><a class="el" href="a00126.html" title="Dijkstra algorithm class.">Dijkstra</a></code> algorithm. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">ComposeMap&lt; M1, M2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of two maps.  <a href="a00091.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">CombineMap&lt; M1, M2, F, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combination of two maps using an STL (binary) functor.  <a href="a00090.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html">FunctorToMap&lt; F, K, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an STL style (unary) functor to a map.  <a href="a00171.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00247.html">MapToFunctor&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a map to an STL style (unary) functor.  <a href="a00247.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">ConvertMap&lt; M, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map adaptor to convert the <code>Value</code> type of a map to another type using the default conversion.  <a href="a00101.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html">ForkMap&lt; M1, M2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies all map setting operations to two maps.  <a href="a00165.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">AddMap&lt; M1, M2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of two maps.  <a href="a00009.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00412.html">SubMap&lt; M1, M2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference of two maps.  <a href="a00412.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00263.html">MulMap&lt; M1, M2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product of two maps.  <a href="a00263.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">DivMap&lt; M1, M2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quotient of two maps.  <a href="a00133.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00388.html">ShiftMap&lt; M, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts a map with a constant.  <a href="a00388.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html">ShiftWriteMap&lt; M, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts a map with a constant (read-write version).  <a href="a00389.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00330.html">ScaleMap&lt; M, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a map with a constant.  <a href="a00330.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00331.html">ScaleWriteMap&lt; M, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a map with a constant (read-write version).  <a href="a00331.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html">NegMap&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative of a map.  <a href="a00267.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">NegWriteMap&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative of a map (read-write version)  <a href="a00268.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">AbsMap&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value of a map.  <a href="a00007.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">AndMap&lt; M1, M2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical 'and' of two maps.  <a href="a00014.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00288.html">OrMap&lt; M1, M2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical 'or' of two maps.  <a href="a00288.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00283.html">NotMap&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical 'not' of a map.  <a href="a00283.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00284.html">NotWriteMap&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical 'not' of a map (read-write version)  <a href="a00284.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html">EqualMap&lt; M1, M2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combination of two maps using the <code>==</code> operator.  <a href="a00148.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html">LessMap&lt; M1, M2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combination of two maps using the <code>&lt;</code> operator.  <a href="a00229.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac36b354e8e808fba48e18cf15db5100f"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr class="memitem:gac36b354e8e808fba48e18cf15db5100f"><td class="memTemplItemLeft" align="right" valign="top">ComposeMap&lt; M1, M2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#gac36b354e8e808fba48e18cf15db5100f">composeMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr class="memdesc:gac36b354e8e808fba48e18cf15db5100f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00091.html" title="Composition of two maps.">ComposeMap</a></code> class.  <a href="#gac36b354e8e808fba48e18cf15db5100f"></a><br/></td></tr>
<tr class="separator:gac36b354e8e808fba48e18cf15db5100f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8530beb88cb34532f35a6e121e0007"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 , typename F , typename V &gt; </td></tr>
<tr class="memitem:gafa8530beb88cb34532f35a6e121e0007"><td class="memTemplItemLeft" align="right" valign="top">CombineMap&lt; M1, M2, F, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#gafa8530beb88cb34532f35a6e121e0007">combineMap</a> (const M1 &amp;m1, const M2 &amp;m2, const F &amp;f)</td></tr>
<tr class="memdesc:gafa8530beb88cb34532f35a6e121e0007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00090.html" title="Combination of two maps using an STL (binary) functor.">CombineMap</a></code> class.  <a href="#gafa8530beb88cb34532f35a6e121e0007"></a><br/></td></tr>
<tr class="separator:gafa8530beb88cb34532f35a6e121e0007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0aac0bb0604df94df88ad5fef5f391c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename F &gt; </td></tr>
<tr class="memitem:gab0aac0bb0604df94df88ad5fef5f391c"><td class="memTemplItemLeft" align="right" valign="top">FunctorToMap&lt; F, K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#gab0aac0bb0604df94df88ad5fef5f391c">functorToMap</a> (const F &amp;f)</td></tr>
<tr class="memdesc:gab0aac0bb0604df94df88ad5fef5f391c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00171.html" title="Converts an STL style (unary) functor to a map.">FunctorToMap</a></code> class.  <a href="#gab0aac0bb0604df94df88ad5fef5f391c"></a><br/></td></tr>
<tr class="separator:gab0aac0bb0604df94df88ad5fef5f391c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a68bad2e29c1486f3cc8d7a0cf056e1"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ga0a68bad2e29c1486f3cc8d7a0cf056e1"><td class="memTemplItemLeft" align="right" valign="top">MapToFunctor&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga0a68bad2e29c1486f3cc8d7a0cf056e1">mapToFunctor</a> (const M &amp;m)</td></tr>
<tr class="memdesc:ga0a68bad2e29c1486f3cc8d7a0cf056e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00247.html" title="Converts a map to an STL style (unary) functor.">MapToFunctor</a></code> class.  <a href="#ga0a68bad2e29c1486f3cc8d7a0cf056e1"></a><br/></td></tr>
<tr class="separator:ga0a68bad2e29c1486f3cc8d7a0cf056e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4abd9551cd490eec5bec69576d4a6dbb"><td class="memTemplParams" colspan="2">template&lt;typename V , typename M &gt; </td></tr>
<tr class="memitem:ga4abd9551cd490eec5bec69576d4a6dbb"><td class="memTemplItemLeft" align="right" valign="top">ConvertMap&lt; M, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga4abd9551cd490eec5bec69576d4a6dbb">convertMap</a> (const M &amp;map)</td></tr>
<tr class="memdesc:ga4abd9551cd490eec5bec69576d4a6dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00101.html" title="Map adaptor to convert the Value type of a map to another type using the default conversion.">ConvertMap</a></code> class.  <a href="#ga4abd9551cd490eec5bec69576d4a6dbb"></a><br/></td></tr>
<tr class="separator:ga4abd9551cd490eec5bec69576d4a6dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7cf375700909175bae19eee48a9962"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr class="memitem:ga7b7cf375700909175bae19eee48a9962"><td class="memTemplItemLeft" align="right" valign="top">ForkMap&lt; M1, M2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga7b7cf375700909175bae19eee48a9962">forkMap</a> (M1 &amp;m1, M2 &amp;m2)</td></tr>
<tr class="memdesc:ga7b7cf375700909175bae19eee48a9962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00165.html" title="Applies all map setting operations to two maps.">ForkMap</a></code> class.  <a href="#ga7b7cf375700909175bae19eee48a9962"></a><br/></td></tr>
<tr class="separator:ga7b7cf375700909175bae19eee48a9962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga198bc5656b8dd90ac511504536a9965a"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr class="memitem:ga198bc5656b8dd90ac511504536a9965a"><td class="memTemplItemLeft" align="right" valign="top">AddMap&lt; M1, M2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga198bc5656b8dd90ac511504536a9965a">addMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr class="memdesc:ga198bc5656b8dd90ac511504536a9965a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code><a class="el" href="a00009.html" title="Sum of two maps.">AddMap</a></code> class.  <a href="#ga198bc5656b8dd90ac511504536a9965a"></a><br/></td></tr>
<tr class="separator:ga198bc5656b8dd90ac511504536a9965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6101bbe8a787e7bf7998d529632edcdd"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr class="memitem:ga6101bbe8a787e7bf7998d529632edcdd"><td class="memTemplItemLeft" align="right" valign="top">SubMap&lt; M1, M2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga6101bbe8a787e7bf7998d529632edcdd">subMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr class="memdesc:ga6101bbe8a787e7bf7998d529632edcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00412.html" title="Difference of two maps.">SubMap</a></code> class.  <a href="#ga6101bbe8a787e7bf7998d529632edcdd"></a><br/></td></tr>
<tr class="separator:ga6101bbe8a787e7bf7998d529632edcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf61fff11e845e77cbd7530b10b75aa17"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr class="memitem:gaf61fff11e845e77cbd7530b10b75aa17"><td class="memTemplItemLeft" align="right" valign="top">MulMap&lt; M1, M2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#gaf61fff11e845e77cbd7530b10b75aa17">mulMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr class="memdesc:gaf61fff11e845e77cbd7530b10b75aa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00263.html" title="Product of two maps.">MulMap</a></code> class.  <a href="#gaf61fff11e845e77cbd7530b10b75aa17"></a><br/></td></tr>
<tr class="separator:gaf61fff11e845e77cbd7530b10b75aa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166e4520ea24f6a0ef094898df89f180"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr class="memitem:ga166e4520ea24f6a0ef094898df89f180"><td class="memTemplItemLeft" align="right" valign="top">DivMap&lt; M1, M2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga166e4520ea24f6a0ef094898df89f180">divMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr class="memdesc:ga166e4520ea24f6a0ef094898df89f180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00133.html" title="Quotient of two maps.">DivMap</a></code> class.  <a href="#ga166e4520ea24f6a0ef094898df89f180"></a><br/></td></tr>
<tr class="separator:ga166e4520ea24f6a0ef094898df89f180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840b730cb65a418b9d890c27dfa63a27"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr class="memitem:ga840b730cb65a418b9d890c27dfa63a27"><td class="memTemplItemLeft" align="right" valign="top">ShiftMap&lt; M, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga840b730cb65a418b9d890c27dfa63a27">shiftMap</a> (const M &amp;m, const C &amp;v)</td></tr>
<tr class="memdesc:ga840b730cb65a418b9d890c27dfa63a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00388.html" title="Shifts a map with a constant.">ShiftMap</a></code> class.  <a href="#ga840b730cb65a418b9d890c27dfa63a27"></a><br/></td></tr>
<tr class="separator:ga840b730cb65a418b9d890c27dfa63a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c1611cd915bd96577b7f5e9607c834b"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr class="memitem:ga9c1611cd915bd96577b7f5e9607c834b"><td class="memTemplItemLeft" align="right" valign="top">ShiftWriteMap&lt; M, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga9c1611cd915bd96577b7f5e9607c834b">shiftWriteMap</a> (M &amp;m, const C &amp;v)</td></tr>
<tr class="memdesc:ga9c1611cd915bd96577b7f5e9607c834b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00389.html" title="Shifts a map with a constant (read-write version).">ShiftWriteMap</a></code> class.  <a href="#ga9c1611cd915bd96577b7f5e9607c834b"></a><br/></td></tr>
<tr class="separator:ga9c1611cd915bd96577b7f5e9607c834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ce03f4c101f1297901c5ce840543006"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr class="memitem:ga7ce03f4c101f1297901c5ce840543006"><td class="memTemplItemLeft" align="right" valign="top">ScaleMap&lt; M, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga7ce03f4c101f1297901c5ce840543006">scaleMap</a> (const M &amp;m, const C &amp;v)</td></tr>
<tr class="memdesc:ga7ce03f4c101f1297901c5ce840543006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00330.html" title="Scales a map with a constant.">ScaleMap</a></code> class.  <a href="#ga7ce03f4c101f1297901c5ce840543006"></a><br/></td></tr>
<tr class="separator:ga7ce03f4c101f1297901c5ce840543006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7cd505ab3725fdf5785746544eea66"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr class="memitem:ga7e7cd505ab3725fdf5785746544eea66"><td class="memTemplItemLeft" align="right" valign="top">ScaleWriteMap&lt; M, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga7e7cd505ab3725fdf5785746544eea66">scaleWriteMap</a> (M &amp;m, const C &amp;v)</td></tr>
<tr class="memdesc:ga7e7cd505ab3725fdf5785746544eea66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00331.html" title="Scales a map with a constant (read-write version).">ScaleWriteMap</a></code> class.  <a href="#ga7e7cd505ab3725fdf5785746544eea66"></a><br/></td></tr>
<tr class="separator:ga7e7cd505ab3725fdf5785746544eea66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47c5a97a29055bfc88314591fdfdf42"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gac47c5a97a29055bfc88314591fdfdf42"><td class="memTemplItemLeft" align="right" valign="top">NegMap&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#gac47c5a97a29055bfc88314591fdfdf42">negMap</a> (const M &amp;m)</td></tr>
<tr class="memdesc:gac47c5a97a29055bfc88314591fdfdf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00267.html" title="Negative of a map.">NegMap</a></code> class.  <a href="#gac47c5a97a29055bfc88314591fdfdf42"></a><br/></td></tr>
<tr class="separator:gac47c5a97a29055bfc88314591fdfdf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacce5676587f1d1e7c7d810cfd2e7ff1"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gaacce5676587f1d1e7c7d810cfd2e7ff1"><td class="memTemplItemLeft" align="right" valign="top">NegWriteMap&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#gaacce5676587f1d1e7c7d810cfd2e7ff1">negWriteMap</a> (M &amp;m)</td></tr>
<tr class="memdesc:gaacce5676587f1d1e7c7d810cfd2e7ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00268.html" title="Negative of a map (read-write version)">NegWriteMap</a></code> class.  <a href="#gaacce5676587f1d1e7c7d810cfd2e7ff1"></a><br/></td></tr>
<tr class="separator:gaacce5676587f1d1e7c7d810cfd2e7ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb163469d214f85023ebb74c2801a0a1"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gabb163469d214f85023ebb74c2801a0a1"><td class="memTemplItemLeft" align="right" valign="top">AbsMap&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#gabb163469d214f85023ebb74c2801a0a1">absMap</a> (const M &amp;m)</td></tr>
<tr class="memdesc:gabb163469d214f85023ebb74c2801a0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code><a class="el" href="a00007.html" title="Absolute value of a map.">AbsMap</a></code> class.  <a href="#gabb163469d214f85023ebb74c2801a0a1"></a><br/></td></tr>
<tr class="separator:gabb163469d214f85023ebb74c2801a0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e998d08fcf3ef385717fdd4e0d983d8"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr class="memitem:ga2e998d08fcf3ef385717fdd4e0d983d8"><td class="memTemplItemLeft" align="right" valign="top">AndMap&lt; M1, M2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga2e998d08fcf3ef385717fdd4e0d983d8">andMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr class="memdesc:ga2e998d08fcf3ef385717fdd4e0d983d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code><a class="el" href="a00014.html" title="Logical &#39;and&#39; of two maps.">AndMap</a></code> class.  <a href="#ga2e998d08fcf3ef385717fdd4e0d983d8"></a><br/></td></tr>
<tr class="separator:ga2e998d08fcf3ef385717fdd4e0d983d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06463d7799cefda558eaec8392160529"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr class="memitem:ga06463d7799cefda558eaec8392160529"><td class="memTemplItemLeft" align="right" valign="top">OrMap&lt; M1, M2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga06463d7799cefda558eaec8392160529">orMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr class="memdesc:ga06463d7799cefda558eaec8392160529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code><a class="el" href="a00288.html" title="Logical &#39;or&#39; of two maps.">OrMap</a></code> class.  <a href="#ga06463d7799cefda558eaec8392160529"></a><br/></td></tr>
<tr class="separator:ga06463d7799cefda558eaec8392160529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32d5dbe669fc9a75c4ab8ee12db0c12"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gac32d5dbe669fc9a75c4ab8ee12db0c12"><td class="memTemplItemLeft" align="right" valign="top">NotMap&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#gac32d5dbe669fc9a75c4ab8ee12db0c12">notMap</a> (const M &amp;m)</td></tr>
<tr class="memdesc:gac32d5dbe669fc9a75c4ab8ee12db0c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00283.html" title="Logical &#39;not&#39; of a map.">NotMap</a></code> class.  <a href="#gac32d5dbe669fc9a75c4ab8ee12db0c12"></a><br/></td></tr>
<tr class="separator:gac32d5dbe669fc9a75c4ab8ee12db0c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac156aa2d3b004c46cd1189aa5459f6e4"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gac156aa2d3b004c46cd1189aa5459f6e4"><td class="memTemplItemLeft" align="right" valign="top">NotWriteMap&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#gac156aa2d3b004c46cd1189aa5459f6e4">notWriteMap</a> (M &amp;m)</td></tr>
<tr class="memdesc:gac156aa2d3b004c46cd1189aa5459f6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="a00284.html" title="Logical &#39;not&#39; of a map (read-write version)">NotWriteMap</a></code> class.  <a href="#gac156aa2d3b004c46cd1189aa5459f6e4"></a><br/></td></tr>
<tr class="separator:gac156aa2d3b004c46cd1189aa5459f6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabcc26e4e6ddc3ff6b98801c115b26bc"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr class="memitem:gaabcc26e4e6ddc3ff6b98801c115b26bc"><td class="memTemplItemLeft" align="right" valign="top">EqualMap&lt; M1, M2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#gaabcc26e4e6ddc3ff6b98801c115b26bc">equalMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr class="memdesc:gaabcc26e4e6ddc3ff6b98801c115b26bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code><a class="el" href="a00148.html" title="Combination of two maps using the == operator.">EqualMap</a></code> class.  <a href="#gaabcc26e4e6ddc3ff6b98801c115b26bc"></a><br/></td></tr>
<tr class="separator:gaabcc26e4e6ddc3ff6b98801c115b26bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c49f5cdfa8c2484f4fd1a8ce476ba14"><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr class="memitem:ga4c49f5cdfa8c2484f4fd1a8ce476ba14"><td class="memTemplItemLeft" align="right" valign="top">LessMap&lt; M1, M2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00597.html#ga4c49f5cdfa8c2484f4fd1a8ce476ba14">lessMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr class="memdesc:ga4c49f5cdfa8c2484f4fd1a8ce476ba14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code><a class="el" href="a00229.html" title="Combination of two maps using the &lt; operator.">LessMap</a></code> class.  <a href="#ga4c49f5cdfa8c2484f4fd1a8ce476ba14"></a><br/></td></tr>
<tr class="separator:ga4c49f5cdfa8c2484f4fd1a8ce476ba14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac36b354e8e808fba48e18cf15db5100f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ComposeMap&lt; M1, M2 &gt; composeMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00091.html" title="Composition of two maps.">ComposeMap</a></code> class.</p>
<p>If <code>m1</code> and <code>m2</code> are maps and the <code>Value</code> type of <code>m2</code> is convertible to the <code>Key</code> of <code>m1</code>, then <code>composeMap(m1,m2)[x]</code> will be equal to <code>m1[m2[x]]</code>. </p>

</div>
</div>
<a class="anchor" id="gafa8530beb88cb34532f35a6e121e0007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CombineMap&lt; M1, M2, F, V &gt; combineMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00090.html" title="Combination of two maps using an STL (binary) functor.">CombineMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>double</code> values, then </p>
<div class="fragment"><div class="line"><a class="code" href="a00597.html#gafa8530beb88cb34532f35a6e121e0007" title="Returns a CombineMap class.">combineMap</a>(m1,m2,<a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/gcc-4.7.3/libstdc++/api" href="http://gcc.gnu.org/onlinedocs/gcc-4.7.3/libstdc++/api/a00878.html">std::plus&lt;double&gt;</a>())</div>
</div><!-- fragment --><p> is equivalent to </p>
<div class="fragment"><div class="line">addMap(m1,m2)</div>
</div><!-- fragment --><p>This function is specialized for adaptable binary function classes and C++ functions. </p>

</div>
</div>
<a class="anchor" id="gab0aac0bb0604df94df88ad5fef5f391c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FunctorToMap&lt; F, K, V &gt; functorToMap </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00171.html" title="Converts an STL style (unary) functor to a map.">FunctorToMap</a></code> class.</p>
<p>This function is specialized for adaptable binary function classes and C++ functions. </p>

</div>
</div>
<a class="anchor" id="ga0a68bad2e29c1486f3cc8d7a0cf056e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MapToFunctor&lt; M &gt; mapToFunctor </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00247.html" title="Converts a map to an STL style (unary) functor.">MapToFunctor</a></code> class. </p>

</div>
</div>
<a class="anchor" id="ga4abd9551cd490eec5bec69576d4a6dbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConvertMap&lt; M, V &gt; convertMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00101.html" title="Map adaptor to convert the Value type of a map to another type using the default conversion.">ConvertMap</a></code> class. </p>

</div>
</div>
<a class="anchor" id="ga7b7cf375700909175bae19eee48a9962"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForkMap&lt; M1, M2 &gt; forkMap </td>
          <td>(</td>
          <td class="paramtype">M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00165.html" title="Applies all map setting operations to two maps.">ForkMap</a></code> class. </p>

</div>
</div>
<a class="anchor" id="ga198bc5656b8dd90ac511504536a9965a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AddMap&lt; M1, M2 &gt; addMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00009.html" title="Sum of two maps.">AddMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>double</code> values, then <code>addMap(m1,m2)[x]</code> will be equal to <code>m1[x]+m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga6101bbe8a787e7bf7998d529632edcdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SubMap&lt; M1, M2 &gt; subMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00412.html" title="Difference of two maps.">SubMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>double</code> values, then <code>subMap(m1,m2)[x]</code> will be equal to <code>m1[x]-m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="gaf61fff11e845e77cbd7530b10b75aa17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MulMap&lt; M1, M2 &gt; mulMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00263.html" title="Product of two maps.">MulMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>double</code> values, then <code>mulMap(m1,m2)[x]</code> will be equal to <code>m1[x]*m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga166e4520ea24f6a0ef094898df89f180"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DivMap&lt; M1, M2 &gt; divMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00133.html" title="Quotient of two maps.">DivMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>double</code> values, then <code>divMap(m1,m2)[x]</code> will be equal to <code>m1[x]/m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga840b730cb65a418b9d890c27dfa63a27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ShiftMap&lt; M, C &gt; shiftMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00388.html" title="Shifts a map with a constant.">ShiftMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values and <code>v</code> is <code>double</code>, then <code>shiftMap(m,v)[x]</code> will be equal to <code>m[x]+v</code>. </p>

</div>
</div>
<a class="anchor" id="ga9c1611cd915bd96577b7f5e9607c834b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ShiftWriteMap&lt; M, C &gt; shiftWriteMap </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00389.html" title="Shifts a map with a constant (read-write version).">ShiftWriteMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values and <code>v</code> is <code>double</code>, then <code>shiftWriteMap(m,v)[x]</code> will be equal to <code>m[x]+v</code>. Moreover it makes also possible to write the map. </p>

</div>
</div>
<a class="anchor" id="ga7ce03f4c101f1297901c5ce840543006"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ScaleMap&lt; M, C &gt; scaleMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00330.html" title="Scales a map with a constant.">ScaleMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values and <code>v</code> is <code>double</code>, then <code>scaleMap(m,v)[x]</code> will be equal to <code>v*m[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga7e7cd505ab3725fdf5785746544eea66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ScaleWriteMap&lt; M, C &gt; scaleWriteMap </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00331.html" title="Scales a map with a constant (read-write version).">ScaleWriteMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values and <code>v</code> is <code>double</code>, then <code>scaleWriteMap(m,v)[x]</code> will be equal to <code>v*m[x]</code>. Moreover it makes also possible to write the map. </p>

</div>
</div>
<a class="anchor" id="gac47c5a97a29055bfc88314591fdfdf42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NegMap&lt; M &gt; negMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00267.html" title="Negative of a map.">NegMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values, then <code>negMap(m)[x]</code> will be equal to <code>-m[x]</code>. </p>

</div>
</div>
<a class="anchor" id="gaacce5676587f1d1e7c7d810cfd2e7ff1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NegWriteMap&lt; M &gt; negWriteMap </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00268.html" title="Negative of a map (read-write version)">NegWriteMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values, then <code>negWriteMap(m)[x]</code> will be equal to <code>-m[x]</code>. Moreover it makes also possible to write the map. </p>

</div>
</div>
<a class="anchor" id="gabb163469d214f85023ebb74c2801a0a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AbsMap&lt; M &gt; absMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00007.html" title="Absolute value of a map.">AbsMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values, then <code>absMap(m)[x]</code> will be equal to <code>m[x]</code> if it is positive or zero and <code>-m[x]</code> if <code>m[x]</code> is negative. </p>

</div>
</div>
<a class="anchor" id="ga2e998d08fcf3ef385717fdd4e0d983d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AndMap&lt; M1, M2 &gt; andMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00014.html" title="Logical &#39;and&#39; of two maps.">AndMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>bool</code> values, then <code>andMap(m1,m2)[x]</code> will be equal to <code>m1[x]&amp;&amp;m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga06463d7799cefda558eaec8392160529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OrMap&lt; M1, M2 &gt; orMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00288.html" title="Logical &#39;or&#39; of two maps.">OrMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>bool</code> values, then <code>orMap(m1,m2)[x]</code> will be equal to <code>m1[x]||m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="gac32d5dbe669fc9a75c4ab8ee12db0c12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NotMap&lt; M &gt; notMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00283.html" title="Logical &#39;not&#39; of a map.">NotMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>bool</code> values, then <code>notMap(m)[x]</code> will be equal to <code>!m[x]</code>. </p>

</div>
</div>
<a class="anchor" id="gac156aa2d3b004c46cd1189aa5459f6e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NotWriteMap&lt; M &gt; notWriteMap </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00284.html" title="Logical &#39;not&#39; of a map (read-write version)">NotWriteMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>bool</code> values, then <code>notWriteMap(m)[x]</code> will be equal to <code>!m[x]</code>. Moreover it makes also possible to write the map. </p>

</div>
</div>
<a class="anchor" id="gaabcc26e4e6ddc3ff6b98801c115b26bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EqualMap&lt; M1, M2 &gt; equalMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00148.html" title="Combination of two maps using the == operator.">EqualMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are maps with keys and values of the same type, then <code>equalMap(m1,m2)[x]</code> will be equal to <code>m1[x]==m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga4c49f5cdfa8c2484f4fd1a8ce476ba14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LessMap&lt; M1, M2 &gt; lessMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00229.html" title="Combination of two maps using the &lt; operator.">LessMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are maps with keys and values of the same type, then <code>lessMap(m1,m2)[x]</code> will be equal to <code>m1[x]&lt;m2[x]</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 10 2013 09:15:34 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
